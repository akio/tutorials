# 
msgid ""
msgstr ""
"Project-Id-Version: jvrc software 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-03-31 17:58+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../basics/howto-exec-simulation.rst:2
msgid "シミュレーションの実行"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:8
msgid "Choreonoidの実行"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:10
msgid "まずはChoreonoidを実行します。端末を開いて以下のコマンドを実行してください。 ::"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:14
msgid "以下のような画面が表示されるはずです。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:19
msgid "モデルを開く"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:21
msgid "まず、「メニュー」の「ファイル」「新規」より「ワールド」を選択し、ワールドアイテム「World」を追加します。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:32
msgid "床を追加する"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:34
msgid "シミュレーションを行うために、床(地面)を追加します。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:36
msgid ""
"Choreonoid の画面にはアイテムと表示されている領域がありますが、これをアイテムビューと呼びます。 "
"まずアイテムビューで「World」を選択します。 "
"次に、「メニュー」の「ファイル」「読み込み」より「OpenHRPモデルファイル」を選択し、床のモデルファイルを開きます。ファイル名は「/usr/share/choreonoid-1.5/model/misc/floor.wrl」です。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:41
msgid "シミュレータアイテムを追加する"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:43
msgid ""
"アイテムビューで「World」を選択します。 "
"次に、「メニュー」の「ファイル」「新規」より「AISTシミュレータ」を選択し、AISTシミュレータ「AISTSimulator」を追加します。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:49
#: ../../basics/rt-controller.rst:201 ../../basics/torque.rst:344
msgid "シミュレーションを実行する"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:51
msgid "次に、シミュレーションツールバーの「シミュレーション開始ボタン」を押します。 これにより、画面上でモデルのシミュレーションが開始されます。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:55
msgid ""
"シミュレーションを実行すると下の画像のようにロボットはすぐに崩れ落ちてしまうはずです。 "
"再生スライダーを動かして詳細に確認すると、0.2秒の段階で足が崩れ始め、1.3秒時点で完全に崩れてしまいます。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:64
msgid "プロジェクトの保存"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:66
msgid ""
"シミュレーションの実行が終わったら、プロジェクトを保存しておきましょう。「ファイル」の「名前を付けてプロジェクトを保存」を選択し、適当なファイル名を付けて保存します。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:69
#: ../../basics/rt-controller.rst:211 ../../basics/torque.rst:354
msgid "サンプルプロジェクトについて"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:71
msgid ""
"このサンプルのプロジェクトファイルは「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/samples/sample1.cnoid」に保存されています。"
msgstr ""

#: ../../basics/index.rst:2
msgid "シミュレーションの基本"
msgstr ""

#: ../../basics/rt-controller.rst:2
msgid "RTコンポーネントのコントローラの接続"
msgstr ""

#: ../../basics/rt-controller.rst:5
msgid "ここではJVRCモデルにRTコンポーネントのコントローラを接続し、ロボットの関節角度を取得できるようにします。"
msgstr ""

#: ../../basics/rt-controller.rst:8 ../../basics/torque.rst:9
msgid "プロジェクトを開く"
msgstr ""

#: ../../basics/rt-controller.rst:10
msgid ""
"「メニュー」の「プロジェクトの読み込み」からJVRCモデルファイル用のプロジェクトファイルを読み込みます。プロジェクトファイル名は「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/samples/sample1.cnoid」です。"
msgstr ""

#: ../../basics/rt-controller.rst:13
msgid "コントローラの追加"
msgstr ""

#: ../../basics/rt-controller.rst:15
msgid ""
"まずアイテムビューで「JVRC」を選択します。 "
"次に、「メニュー」の「ファイル」「新規」より「BodyRTC」を選択し「BodyRTC」という名前で追加します。"
msgstr ""

#: ../../basics/rt-controller.rst:19 ../../basics/torque.rst:16
msgid "コントローラのソースコード"
msgstr ""

#: ../../basics/rt-controller.rst:21 ../../basics/torque.rst:18
msgid ""
"コントローラのヘッダのソースコードは以下になります。Choreonoidに含まれるサンプルのSR1WalkControllerRTC.hを基にしています。"
" ::"
msgstr ""

#: ../../basics/rt-controller.rst:63
msgid ""
"`RTC::TimedDoubleSeq` というのは、時刻情報とdouble型の実際の値を持つOpenRTM固有の複合型です。 "
"SeqはOpenRTMにおける配列型のように扱います。 OpenRTMにおけるdouble[]型と考えておけばよいでしょう。"
msgstr ""

#: ../../basics/rt-controller.rst:67
msgid ""
"`RTC::InPort<RTC::TimedDoubleSeq>` はRTCの入力ポートを表す型であり、入力ポートを操作するにはこれを利用します。 "
"m_angleは入力ポートから関節角度を受けとるための変数です。m_angleInで取得した値はm_angleで参照します。"
msgstr ""

#: ../../basics/rt-controller.rst:70 ../../basics/torque.rst:75
msgid ""
"コントローラのソースコードは以下になります。Choreonoidに含まれるサンプルのSR1WalkControllerRTC.cppを基にしています。 "
"::"
msgstr ""

#: ../../basics/rt-controller.rst:163
msgid "RobotControllerRTCのコンストラクタで、 m_angleIn と m_angle を関連付けています。"
msgstr ""

#: ../../basics/rt-controller.rst:165
msgid "RTCの初期化時に呼ばれるonInitialize()で、m_angleInをRTCの入力ポートqと関連づけています。"
msgstr ""

#: ../../basics/rt-controller.rst:167
msgid ""
"onExecute()はRTCの実行中に定期的に呼ばれます。ここでは関節角度を取得し標準出力に表示する処理を行っています。 "
"m_angleIn.isNew()とは新しいデータが到着しているか確認する関数です。 "
"onExecute()の実行時にはデータが到着しているかどうかが分からないので、ここでチェックしています。新しいデータが来ていた場合にはm_angleIn.read()でデータを読み込みます。読み込んだデータは自動的にm_angleに格納され、m_angle.dataとして取得できます。"
" m_angle.dataは各関節毎に配列の値となっています。"
msgstr ""

#: ../../basics/rt-controller.rst:172
msgid ""
"これらのソースコードは「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/RTC/RobotControllerRTC.cpp」と「model/robot/RTC/RobotControllerRTC.h」に保存されています。"
msgstr ""

#: ../../basics/rt-controller.rst:175 ../../basics/torque.rst:265
msgid "コントローラの設定"
msgstr ""

#: ../../basics/rt-controller.rst:177
msgid "プロジェクト上でRTコンポーネント(RTC)を作成しただけでは、ロボットの制御を行うことができません。"
msgstr ""

#: ../../basics/rt-controller.rst:179
msgid ""
"アイテムビューで「BodyRTC」を選択するとプロパティのタブ(プロパティビューと言います)にRTCの設定が表示されます。 "
"プロパティビューの「コントローラのモジュール名」を「RobotControllerRTC」とします。これは「コントローラのビルド」で作成したモジュールのパスと対応しています。"
" さらに、プロパティビューの「自動ポート接続」を true にします。"
msgstr ""

#: ../../basics/rt-controller.rst:186 ../../basics/torque.rst:330
msgid "コントローラのビルド"
msgstr ""

#: ../../basics/rt-controller.rst:188 ../../basics/torque.rst:332
msgid ""
"「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/RTC/」ディレクトリに移動し、次のコマンドを実行します。 ::"
msgstr ""

#: ../../basics/rt-controller.rst:192
msgid ""
"これにより、「model/robot/RTC/」ディレクトリに「RobotControllerRTC.so」というファイルが作成されるはずです。"
msgstr ""

#: ../../basics/rt-controller.rst:194 ../../basics/torque.rst:338
msgid "その後、次のコマンドを実行します。 ::"
msgstr ""

#: ../../basics/rt-controller.rst:198
msgid ""
"Choreonoidでは読み込むRTCコントローラのモジュールはChoreonoidのインストール先の共有ディレクトリ(/usr/lib/choreonoid-1.5/rtc)に配置しなければなりません。\"make"
" install\"ではこの処理を自動的に行ってくれます。"
msgstr ""

#: ../../basics/rt-controller.rst:203
msgid ""
"シミュレーションツールバーの「シミュレーション開始ボタン」を押します。 "
"シミュレーションを実行するとchoreonoidを実行している端末に関節角度(m_angle)の値が表示されるはずです。"
msgstr ""

#: ../../basics/rt-controller.rst:208
msgid "このようにして得られる関節角度を基にトルクをロボットに入力することでロボットの制御を行うことができます。この後のサンプルで詳しく解説します。"
msgstr ""

#: ../../basics/rt-controller.rst:213
msgid ""
"このサンプルのプロジェクトファイルは「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/samples/sample2.cnoid」に保存されています。"
msgstr ""

#: ../../basics/torque.rst:2
msgid "RTコンポーネントにおけるトルク指令の入力"
msgstr ""

#: ../../basics/torque.rst:5
msgid "ここでは、トルク指令を出力するようにRTコンポーネントを拡張し、ロボットが直立を 維持できるようにします。"
msgstr ""

#: ../../basics/torque.rst:11
msgid ""
"「メニュー」の「プロジェクトの読み込み」から JVRC モデルファイル用のプロジェク "
"トファイルを読み込みます。プロジェクトファイル名は「モデルファイルのインス "
"トール」でダウンロードしたリポジトリの「model/robot/samples/sample2.cnoid」です。"
msgstr ""

#: ../../basics/torque.rst:72
msgid ""
"今回はトルクの出力をしなければならないので、出力ポートのための設定が増加しています。 "
"`RTC::OutPort<RTC::TimedDoubleSeq>` はRTCの出力ポートを表す型であり、出力ポートを操作するにはこれを利用します。"
msgstr ""

#: ../../basics/torque.rst:247
msgid "出力ポートに関する設定は、入力ポートの場合と関数名が異なるだけでよく似ています。"
msgstr ""

#: ../../basics/torque.rst:254
msgid ""
"onExecute()ではトルクの計算と出力の処理が追加されました。 関節角度を読み込む部分のコードはこれまでと同じですが、 "
"`m_torque.data[i]` に計算したトルクの値を代入しています。 ここでは簡単なPD制御によりトルクの値を求めています。 "
"各関節毎のPgainとDgainはソースコードの先頭付近に固定値で定義されています。 ロボットがうまく制御できない場合はこの値を調整する必要があります。"
" `m_torque.data` にセットした値は `m_torqueOut.write()` により実際のロボットの制御トルクとして出力されます。 "
"出力ポートは値をセットするだけなので入力ポートよりも簡単です。"
msgstr ""

#: ../../basics/torque.rst:262
msgid ""
"これらのソースコードは "
"「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/RTC/RobotTorqueControllerRTC.cpp」と"
" 「model/robot/RTC/RobotTorqueControllerRTC.h」に保存されています。"
msgstr ""

#: ../../basics/torque.rst:267
msgid ""
"アイテムビューで「BodyRTC」を選択し、プロパティビューの「コントローラのモジュール名」を「RobotTorqueControllerRTC」とします。これは「コントローラのビルド」で作成したモジュールのパスと対応しています。"
" さらに、プロパティビューの「自動ポート接続」を true にします。"
msgstr ""

#: ../../basics/torque.rst:277
msgid "タイムバーの設定画面を開きます。"
msgstr ""

#: ../../basics/torque.rst:281
msgid "「内部フレームレート」の項目を下記のように「1000」に設定します。"
msgstr ""

#: ../../basics/torque.rst:285
msgid "このフレームレートは1秒間に何回実行するかを表しています。 これが1000で1ミリ秒の間隔となり、100で10ミリ秒間隔となります。"
msgstr ""

#: ../../basics/torque.rst:289
msgid "ポーズ列の追加"
msgstr ""

#: ../../basics/torque.rst:291
msgid ""
"まずアイテムビューで「JVRC」を選択します。 "
"次に、「メニュー」の「ファイル」「新規」より「ポーズ列」を選択し「SampleMotion」という名前で追加します。"
msgstr ""

#: ../../basics/torque.rst:296
msgid "次に、「表示」の「ビューの表示」から「ポーズロール」を選択します。次の画面が表示されるはずです。"
msgstr ""

#: ../../basics/torque.rst:300
msgid "基準の姿勢を作るため、アイテムビューで「JVRC」を選択し、ツールバーにある「選択ボディを初期姿勢に」のボタンを押します。"
msgstr ""

#: ../../basics/torque.rst:304
msgid "ポーズロールにおいて、1.0 を選択して「挿入」を押します。 同様に 2.0, 3.0, 4.0 を選択して「挿入」を押します。"
msgstr ""

#: ../../basics/torque.rst:307
msgid "ポーズロールは次のようになるはずです。"
msgstr ""

#: ../../basics/torque.rst:311
msgid "あとはこれを繰り返し、15.0まで生成します。"
msgstr ""

#: ../../basics/torque.rst:313
msgid ""
"ポーズロールで作成したのはキーフレームと呼びます。これより、プログラムで使用するモーションを生成させます。 "
"ツールバーから「ボディモーションの生成」ボタンを押します。"
msgstr ""

#: ../../basics/torque.rst:318
msgid ""
"モーションはツールバーのボタンで手動で生成しなくても、キーフレームの更新時に自動生成することができます。 "
"これを有効にするにはツールバーの「自動更新モード」のボタンをオンにしてください。"
msgstr ""

#: ../../basics/torque.rst:323
msgid "SampleMotion の子供に motion があるので、これを選択し名前を付けて保存ボタンを押します。"
msgstr ""

#: ../../basics/torque.rst:327
msgid ""
"「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/RTC/」ディレクトリに「RobotMotion.yaml」というファイルで保存します。"
msgstr ""

#: ../../basics/torque.rst:336
msgid ""
"これにより、「model/robot/RTC/」ディレクトリに「RobotTorqueControllerRTC.so」というファイルが作成されるはずです。"
msgstr ""

#: ../../basics/torque.rst:356
msgid ""
"このサンプルのプロジェクトファイルは「モデルファイルのインストール」でダウン "
"ロードしたリポジトリの「model/robot/samples/sample3.cnoid」に保存されています。"
msgstr ""

#: ../../basics/torque.rst:346
msgid ""
"シミュレーションツールバーの「シミュレーション開始ボタン」を押します。 "
"シミュレーションを実行すると今度はなかなかロボットが崩れ落ちず、シミュレーション時間で15秒間の間立ったままの状態になったはずです。 "
"これは、JVRCの制御を行うためのモーションデータが15秒ぶんしか用意していないためです。"
msgstr ""

#: ../../basics/index.rst:4
msgid "この章ではJVRCモデルファイルを用いた基本的なシミュレーションの実行方法について解説します。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:5
msgid "この節ではサンプルシミュレーションの実行方法について解説します。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:23
msgid ""
"そのまま「メニュー」の「ファイル」「読み込み」より「OpenHRPモデルファイル」を選択し、JVRC-"
"1のモデルファイルを読み込みます。ファイル名はモデルファイルを展開したディレクトリのmain.wrlです。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:25
msgid ""
"モデルを読み込んだだけではロボットは表示されません。 「アイテム」と書かれたリストのJVRC-1にチェックを入れてください。 "
"すると、以下のようにロボットが表示されるはずです。"
msgstr ""

#: ../../basics/howto-exec-simulation.rst:60
msgid "これは全く関節の制御をしていないためです。 これからロボットを制御するプログラムを記述し、ロボットが崩れ落ちないようにしていきます。"
msgstr ""

#: ../../basics/torque.rst:249
msgid ""
"onActivated() のときの処理に注目しましょう。この関数はRTCが有効化された際に一度だけ呼ばれます。 "
"ここで、Choreonoidの共有ディレクトリからRobotPattern.yamlを読み出しています。 "
"これはロボットの全関節角度の軌道を記述した動作パターンファイルです。 `motion.loadStandardYAMLformat()` "
"によりモーションデータに変換します。 onActivated()では初期値の設定も行っています。"
msgstr ""

#: ../../basics/torque.rst:273
msgid "シミュレーション用動作パターンの作成"
msgstr ""

#: ../../basics/torque.rst:275
msgid ""
"ロボットの関節の制御を行うRTコンポーネントの実行周期に合わせて、ロボットの動作パターンを生成するための設定を行います。RTコンポーネントは1[ms]周期で実行されるので、Choreonoidの内部フレームレートを1000に設定します。"
msgstr ""

#~ msgid ""
#~ "onActivated() のときの処理に注目しましょう。この関数はRTCが有効化された際に一度だけ呼ばれます。 "
#~ "ここで、Choreonoidの共有ディレクトリからRobotPattern.yamlを読み出しています。 "
#~ "これは制御の際の基準となるフレームファイルです。 `motion.loadStandardYAMLformat()` "
#~ "によりモーションデータに変換します。 onActivated()では初期値の設定も行っています。"
#~ msgstr ""

#~ msgid "シミュレーションの設定"
#~ msgstr ""

#~ msgid ""
#~ "Choreonoidにおけるシミュレーションの初期実行間隔は10msとあまりに粗く、今回のロボットの制御には向いていません。 "
#~ "シミュレーションの実行間隔を細かくすることで、 この作業はモーションを生成する前に行う必要があります。"
#~ msgstr ""

#~ msgid "pgain, dgain の調整について"
#~ msgstr ""

#~ msgid ""
#~ "ポーズを決めてモーションを生成し、コントローラで読み込んでシミュレーションさせたとしても、うまくロボットは制御できません。 "
#~ "制御がないとロボットは崩れてしまい、制御をやりすぎるとロボットはどこかへ飛んでいってしまいます。 そのため、各関節のpgain, "
#~ "dgainを細かく調整する必要があります。"
#~ msgstr ""

#~ msgid ""
#~ "制御の簡単な方針として、シミュレーション中にトルクや dq の値を表示させ、明らかに変化が激しくなっている関節角度のpgainを増加させます。 "
#~ "またはシミュレーションの描画中に不安定になっている関節の関節番号を確認し、その関節角度のpgainを増加させます。 dgain "
#~ "は少し値を変えただけでロボットが飛んでいくほど影響が大きいので、値の調整は難しいです。"
#~ msgstr ""

#~ msgid ""
#~ "そのまま「メニュー」の「ファイル」「読み込み」より「OpenHRPモデルファイル」を選択し、JVRCモデルファイルを読み込みます。ファイル名は「モデルファイルのインストール」でダウンロードしたリポジトリの「model/robot/robot.yaml」です。"
#~ msgstr ""

#~ msgid ""
#~ "モデルを読み込んだだけではロボットは表示されません。 「アイテム」と書かれたリストのJVRCにチェックを入れてください。 "
#~ "すると、以下のようにロボットが表示されるはずです。"
#~ msgstr ""

#~ msgid "これは全く制御をしていないためです。 これからロボットを制御するプログラムを記述し、ロボットが崩れ落ちないようにしていきます。"
#~ msgstr ""

#~ msgid "本ドキュメントではサンプルシミュレーションの実行方法について解説します。"
#~ msgstr ""

#~ msgid "本ドキュメントではJVRCモデルファイルを用いた基本的なシミュレーションの実行方法について解説します。"
#~ msgstr ""

#~ msgid ""
#~ "シミュレーションツールバーの「シミュレーション開始ボタン」を押します。 "
#~ "シミュレーションを実行すると今度はなかなかロボットが崩れ落ちず、シミュレーション時間で4秒間の間立ったままの状態になったはずです。"
#~ msgstr ""
